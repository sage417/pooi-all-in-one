// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dns {
    #[prost(string, repeated, tag = "1")]
    pub listen_addrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "3")]
    pub hosts: ::std::collections::HashMap<::prost::alloc::string::String, dns::Ips>,
}
/// Nested message and enum types in `Dns`.
pub mod dns {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ips {
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Log {
    #[prost(enumeration = "log::Level", tag = "1")]
    pub level: i32,
    #[prost(enumeration = "log::Output", tag = "2")]
    pub output: i32,
    #[prost(string, tag = "3")]
    pub output_file: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Log`.
pub mod log {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Level {
        Info = 0,
        Trace = 1,
        Debug = 2,
        Warn = 3,
        Error = 4,
        None = 5,
    }
    impl Level {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Info => "INFO",
                Self::Trace => "TRACE",
                Self::Debug => "DEBUG",
                Self::Warn => "WARN",
                Self::Error => "ERROR",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INFO" => Some(Self::Info),
                "TRACE" => Some(Self::Trace),
                "DEBUG" => Some(Self::Debug),
                "WARN" => Some(Self::Warn),
                "ERROR" => Some(Self::Error),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Output {
        Console = 0,
        File = 1,
    }
    impl Output {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Console => "CONSOLE",
                Self::File => "FILE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONSOLE" => Some(Self::Console),
                "FILE" => Some(Self::File),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TunInboundSettings {
    #[prost(int32, tag = "1")]
    pub fd: i32,
    #[prost(bool, tag = "9")]
    pub auto: bool,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub gateway: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub netmask: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub mtu: i32,
    #[prost(string, repeated, tag = "7")]
    pub fake_dns_exclude: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub fake_dns_include: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CatInboundSettings {
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub port: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShadowsocksInboundSettings {
    #[prost(string, tag = "1")]
    pub method: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TrojanInboundSettings {
    #[prost(string, repeated, tag = "1")]
    pub passwords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WebSocketInboundSettings {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AMuxInboundSettings {
    #[prost(string, repeated, tag = "1")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NfInboundSettings {
    #[prost(string, tag = "1")]
    pub driver_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub nfapi: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub fake_dns_exclude: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub fake_dns_include: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuicInboundSettings {
    #[prost(string, tag = "1")]
    pub certificate: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub certificate_key: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub alpn: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TlsInboundSettings {
    #[prost(string, tag = "1")]
    pub certificate: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub certificate_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChainInboundSettings {
    #[prost(string, repeated, tag = "1")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HcInboundSettings {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub response: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Inbound {
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    /// TODO use enum
    #[prost(string, tag = "2")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub port: u32,
    #[prost(bytes = "vec", tag = "5")]
    pub settings: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RedirectOutboundSettings {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub port: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SocksOutboundSettings {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub port: u32,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShadowsocksOutboundSettings {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub port: u32,
    /// TODO use enum
    #[prost(string, tag = "3")]
    pub method: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub prefix: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ObfsOutboundSettings {
    /// TODO use enum
    #[prost(string, tag = "1")]
    pub method: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub host: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TrojanOutboundSettings {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub port: u32,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TlsOutboundSettings {
    #[prost(string, tag = "1")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub alpn: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub certificate: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub insecure: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebSocketOutboundSettings {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TryAllOutboundSettings {
    #[prost(string, repeated, tag = "1")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "2")]
    pub delay_base: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StaticOutboundSettings {
    #[prost(string, repeated, tag = "1")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub method: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AMuxOutboundSettings {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub port: u32,
    #[prost(string, repeated, tag = "3")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub max_accepts: u32,
    #[prost(uint32, tag = "5")]
    pub concurrency: u32,
    #[prost(uint64, tag = "6")]
    pub max_recv_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub max_lifetime: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuicOutboundSettings {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub port: u32,
    #[prost(string, tag = "3")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub certificate: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub alpn: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VMessOutboundSettings {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub port: u32,
    #[prost(string, tag = "3")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub security: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChainOutboundSettings {
    #[prost(string, repeated, tag = "1")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FailOverOutboundSettings {
    /// A list of outbound tags.
    #[prost(string, repeated, tag = "1")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The connect timeout value for the outbounds, in seconds. Some outbounds don't
    /// need to "connect", those outbounds have zero connect time. Default 4.
    #[prost(uint32, tag = "2")]
    pub fail_timeout: u32,
    /// Enable health check, to use other health check options, this must be true. Default
    /// true.
    #[prost(bool, tag = "3")]
    pub health_check: bool,
    /// Health check frequency, in seconds.
    #[prost(uint32, tag = "4")]
    pub check_interval: u32,
    /// Use the next outbound if the current one failed, e.g. it's timeout. Default true.
    #[prost(bool, tag = "5")]
    pub failover: bool,
    #[prost(bool, tag = "6")]
    pub fallback_cache: bool,
    #[prost(uint32, tag = "7")]
    pub cache_size: u32,
    #[prost(uint32, tag = "8")]
    pub cache_timeout: u32,
    /// The outbound to be used when all actors are unavailable.
    #[prost(string, optional, tag = "9")]
    pub last_resort: ::core::option::Option<::prost::alloc::string::String>,
    /// Timeout for health check request, in seconds. Default is 6.
    #[prost(uint32, tag = "10")]
    pub health_check_timeout: u32,
    /// Put a random delay from (0..health_check_delay] before each health check, in
    /// milliseconds. Default is 200.
    #[prost(uint32, tag = "11")]
    pub health_check_delay: u32,
    /// Health check would stop running if no incoming requests in this period, it's
    /// considered the outbound is inactive, in seconds. Default is 900.
    #[prost(uint32, tag = "12")]
    pub health_check_active: u32,
    /// Specify a list of preferred outbounds, these outbounds would have higher priority
    /// if they are in good health.
    #[prost(string, repeated, tag = "13")]
    pub health_check_prefers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Health check would run on start if this is true, by default health check would
    /// start to run when the first request comes in. Default is false.
    #[prost(bool, tag = "14")]
    pub health_check_on_start: bool,
    /// Hold incomming connections, wait for the initial health check to be done.
    /// Default false.
    #[prost(bool, tag = "15")]
    pub health_check_wait: bool,
    /// Total number of health check requests per outbound, the RTT to be used to sort
    /// the outbounds is the average of all successful attempts. Default 1.
    #[prost(uint32, tag = "16")]
    pub health_check_attempts: u32,
    /// The percentage of successful health check requests which to consider an outbound
    /// is available, must be a value between \[0, 100\], if the result is lower than this
    /// percentage, the outbound's RTT would be set to a timeout value, thus marks the
    /// outbound as unavailable. Default 50.
    #[prost(uint32, tag = "17")]
    pub health_check_success_percentage: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SelectOutboundSettings {
    #[prost(string, repeated, tag = "1")]
    pub actors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PluginOutboundSettings {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub args: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Outbound {
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    /// TODO use enum
    #[prost(string, tag = "2")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub settings: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Router {
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<router::Rule>,
    #[prost(bool, tag = "2")]
    pub domain_resolve: bool,
}
/// Nested message and enum types in `Router`.
pub mod router {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Rule {
        #[prost(string, tag = "1")]
        pub target_tag: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub domains: ::prost::alloc::vec::Vec<rule::Domain>,
        #[prost(string, repeated, tag = "3")]
        pub ip_cidrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "4")]
        pub mmdbs: ::prost::alloc::vec::Vec<rule::Mmdb>,
        #[prost(string, repeated, tag = "5")]
        pub port_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "6")]
        pub networks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "7")]
        pub inbound_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "8")]
        pub process_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `Rule`.
    pub mod rule {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Domain {
            #[prost(enumeration = "domain::Type", tag = "1")]
            pub r#type: i32,
            #[prost(string, tag = "2")]
            pub value: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `Domain`.
        pub mod domain {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Plain = 0,
                Domain = 1,
                Full = 2,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Plain => "PLAIN",
                        Self::Domain => "DOMAIN",
                        Self::Full => "FULL",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "PLAIN" => Some(Self::Plain),
                        "DOMAIN" => Some(Self::Domain),
                        "FULL" => Some(Self::Full),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Mmdb {
            #[prost(string, tag = "1")]
            pub file: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub country_code: ::prost::alloc::string::String,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    #[prost(message, optional, tag = "1")]
    pub log: ::core::option::Option<Log>,
    #[prost(message, repeated, tag = "2")]
    pub inbounds: ::prost::alloc::vec::Vec<Inbound>,
    #[prost(message, repeated, tag = "3")]
    pub outbounds: ::prost::alloc::vec::Vec<Outbound>,
    #[prost(message, optional, tag = "4")]
    pub router: ::core::option::Option<Router>,
    #[prost(message, optional, tag = "5")]
    pub dns: ::core::option::Option<Dns>,
}
